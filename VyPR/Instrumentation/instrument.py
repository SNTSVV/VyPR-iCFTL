"""
Module containing the logic for adding instrumentation code based on the results of static analysis with respect to iCFTL specifications.
"""

import os
import ast
import pprint
from shutil import copyfile

from VyPR.Instrumentation.analyse import Analyser
from VyPR.Instrumentation.prepare import prepare_specification
from VyPR.Specifications.constraints import (ValueInConcreteState,
                                                DurationOfTransition,
                                                ConcreteStateBeforeTransition,
                                                ConcreteStateAfterTransition,
                                                TimeBetween)
from VyPR.SCFG.prepare import construct_scfg_of_function

class Instrument():
    """
    Class used to invoke Analyser in order to perform static analysis,
    modify the ASTs of files to be instrumented and perform the final compilation.
    """

    def __init__(self, specification_file: str, root_directory: str):
        """
        Invoke analyser with the specification file and root directory given.
        """
        # store the root directory
        self._root_directory = root_directory

        # import specification from the file given
        self._specification = prepare_specification(specification_file)

        # instantiate the analyser
        self._analyser = Analyser(self._specification, root_directory)

        # get the list of all modules that contain functions referred to in the specification
        self._all_modules = self._analyser.get_all_modules()

        # reset instrumented files
        self._reset_instrumented_files()

        # get the ASTs and lines of each of these modules
        self._module_to_ast_list = {}
        self._module_to_lines = {}
        # iterate through modules and construct ASTs for each
        for module in self._all_modules:
            # get asts
            self._module_to_ast_list[module] = self._get_asts_from_module(module)
            # get code lines
            self._module_to_lines[module] = self._get_lines_from_module(module)

        # get the list of all functions used in the specification
        self._all_functions = self._analyser.get_all_functions()

        # get the scfg of each of these functions
        # initialise empty map
        self._function_name_to_scfg_map = {}
        # get SCFG and AST for each function
        for function in self._all_functions:
            # get module from function
            module = self._get_module_from_function(function)
            # get scfg for this function based on self._filename_to_ast_list[filename]
            self._function_name_to_scfg_map[function] = \
                construct_scfg_of_function(module, self._module_to_ast_list[module], function)
        
        # initialise the analyser class
        self._analyser.initialise(self._function_name_to_scfg_map)

        # compute the instrumentation tree
        self._instrumentation_tree = self._analyser.compute_instrumentation_points()
    
    def _reset_instrumented_files(self):
        """
        For each module in self._all_modules, if the backup generated by VyPR exists,
        rename it to the original filename.
        """
        # iterate through modules
        for module in self._all_modules:
            # get backup and original filenames
            backup_filename = self._get_backup_filename_from_module(module)
            original_filename = self._get_original_filename_from_module(module)
            # check for existence
            if os.path.isfile(backup_filename):
                # rename
                os.rename(backup_filename, original_filename)
    
    def _get_module_from_function(self, function: str) -> str:
        """
        Given a function name, extract the module.
        """
        # split the function name
        sequence = function.split(".")
        # remove the function part
        module_part = sequence[:-1]
        # join to get the module name
        module_name = ".".join(module_part)
        return module_name
    
    def _get_asts_from_module(self, module: str) -> list:
        """
        Given a module, get its filename, read in the code from it and construct the ASTs.
        """
        # get filename
        filename = os.path.join(self._root_directory, f"{module}.py")
        # construct file handle
        with open(filename, "r") as h:
            code = h.read()
            asts = ast.parse(code)
            
        return asts
    
    def _get_lines_from_module(self, module: str) -> list:
        """
        Given a module, gets its filename and read in the code lines from it.
        """
        # get filename
        filename = os.path.join(self._root_directory, f"{module}.py")
        # construct file handle
        with open(filename, "r") as h:
            # get trippes lines
            lines = list(map(lambda line : line.rstrip(), h.readlines()))
        
        return lines
    
    def insert_instruments(self):
        """
        Traverse the instrumentation tree structure and, for each symbolic state,
        place an instrument at an appropriate position around the AST provided by the symbolic state.
        """
        # get atomic constraints of the specification so we can decide on what each instrument should look like
        atomic_constraints = self._specification.get_constraint().get_atomic_constraints()
        # traverse self._instrumentation_tree
        for map_index in self._instrumentation_tree:
            for atom_index in self._instrumentation_tree[map_index]:
                # get the atom at atom_index
                relevant_atom = atomic_constraints[atom_index]
                # iterate through the subatom indices
                for subatom_index in self._instrumentation_tree[map_index][atom_index]:
                    # get the subatom at subatom_index
                    relevant_subatom = relevant_atom.get_expression(subatom_index)
                    # iterate through the symbolic states
                    for symbolic_state in self._instrumentation_tree[map_index][atom_index][subatom_index]:
                        # get the index in the block of asts where the instrument's code will be inserted
                        index_in_block = symbolic_state.get_ast_object().parent_block.index(symbolic_state.get_ast_object())
                        # get the line number at which to insert the code
                        line_number = symbolic_state.get_ast_object().parent_block[index_in_block].lineno
                        # get the index in the list of lines
                        line_index = line_number - 1
                        # get the function inside which symbolic_state is found
                        function = self._analyser.get_scfg_searcher().get_function_name_of_symbolic_state(symbolic_state)
                        # derive the module name from the function
                        module = self._get_module_from_function(function)
                        # generate and insert the instrument code
                        self._insert_instrument_code(
                            module,
                            line_index,
                            map_index,
                            atom_index,
                            subatom_index,
                            relevant_subatom
                        )
    
    def get_indentation_level_of_stmt(self, stmt: str) -> int:
        """
        Given a statement, assuming indentation is performed using spaces, count the number of spaces.
        """
        # initialise number of spaces
        number_of_spaces = 0
        # iterate through the string until a non-space character is found
        for i in range(len(stmt)):
            if stmt[i] != " ":
                break
            else:
                number_of_spaces += 1
        
        return number_of_spaces
    
    def _insert_instrument_code(self, module_name: str, line_index: int, map_index: int, atom_index: int, subatom_index: int, relevant_subatom):
        """
        Given all of the necessary information, insert the relevant instrumentation code.
        """
        # get the module lines
        module_lines = self._module_to_lines[module_name]
        # get the indentation level of the code to be inserted
        indentation_level = self.get_indentation_level_of_stmt(module_lines[line_index])
        # generate instrument code
        instrument_code = self._generate_instrument_code(relevant_subatom, map_index, atom_index, subatom_index, indentation_level)
        # check type of returned code - can be either list or string
        # string for single instruments, list for three instruments when a duration must be measured
        # (first and second timestamps, difference measurement)
        if type(instrument_code) is str:
            # place the code at a single location
            module_lines.insert(line_index+1, instrument_code)
        elif type(instrument_code) is list:
            # place the first statement before the target line, the second after it and the third after that one
            # insert the instruments backwards
            module_lines.insert(line_index+1, instrument_code[2])
            module_lines.insert(line_index+1, instrument_code[1])
            module_lines.insert(line_index, instrument_code[0])
    
    def _generate_instrument_code(self, subatom, map_index: int, atom_index: int, subatom_index: int, indentation_level: int) -> str:
        """
        Given the map, atom and subatom indices, generate the code to insert based on the subatom type
        """
        # define code template
        # TODO: make function the instrument calls a parameter
        # construct the indentation string
        indentation = " "*indentation_level
        # check the instrument type
        if type(subatom) is ValueInConcreteState:
            # construct the measurement code
            measurement_code = f"measurement = {subatom.get_program_variable()}"
            # construct the instrument code
            code = f"""{indentation}{measurement_code}; print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}, measurement = %s" % measurement)"""
        elif type(subatom) is TimeBetween:
            # construct measurement code
            measurement_code = f"ts_{subatom_index} = datetime.datetime.now()"
            # construct the instrument code
            code = f"""{indentation}{measurement_code}; print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}, measurement = %s" % ts_{subatom_index})"""
        elif type(subatom) is DurationOfTransition:
            # construct measurement code
            measurement_start_code = "ts_start = datetime.datetime.now()"
            measurement_end_code = "ts_end = datetime.datetime.now()"
            measurement_difference_code = "duration = ts_end - ts_start"
            # construct the instrument code
            code_part_1 = \
                f"""{indentation}{measurement_start_code}; print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}, measurement = %s" % ts_start)"""
            code_part_2 = \
                f"""{indentation}{measurement_end_code}; print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}, , measurement = %s" % ts_end)"""
            code_part_3 = \
                f"""{indentation}{measurement_difference_code}; print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}, measurement = %s" % duration)"""
            code = [code_part_1, code_part_2, code_part_3]
        
        return code
    
    def _get_original_filename_from_module(self, module: str) -> str:
        """
        Given a module name, derive its filename.
        """
        # begin to convert to filename
        with_slashes = module.replace(".", "/").replace(".py", "")
        # join with root directory
        filename = os.path.join(self._root_directory, f"{with_slashes}.py")
        return filename
    
    def _get_backup_filename_from_module(self, module: str) -> str:
        """
        Given a module name, derive its filename.
        """
        # begin to convert to filename
        with_slashes = module.replace(".", "/").replace(".py", "")
        # join with root directory
        filename = os.path.join(self._root_directory, f"{with_slashes}_vypr_original.py")
        return filename
    
    def compile(self):
        """
        Given the modified source code of the modules, write new files (backup old files).
        """
        # iterate through modules
        for module in self._all_modules:

            # get lines for this module
            lines = self._module_to_lines[module]
            # add new lines
            lines = list(map(lambda line : f"{line}\n", lines))

            # get the original and backup filenames from the module
            original_filename = self._get_original_filename_from_module(module)
            backup_filename = self._get_backup_filename_from_module(module)

            # if it exists, rename the backup to the original
            if os.path.isfile(backup_filename):
                os.rename(backup_filename, original_filename)
            
            # copy the original to a backup
            copyfile(original_filename, backup_filename)

            # write the lines for the module to the source file
            with open(original_filename, "w") as h:
                h.writelines(lines)