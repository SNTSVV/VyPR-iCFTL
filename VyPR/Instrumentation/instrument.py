"""
Module containing the logic for adding instrumentation code based on the results of static analysis with respect to iCFTL specifications.
"""

import os
import ast
import pprint
from shutil import copyfile

from VyPR.Instrumentation.analyse import Analyser
from VyPR.SCFG.prepare import construct_scfg_of_function

class Instrument():
    """
    Class used to invoke Analyser in order to perform static analysis,
    modify the ASTs of files to be instrumented and perform the final compilation.
    """

    def __init__(self, specification_file: str, root_directory: str):
        """
        Invoke analyser with the specification file and root directory given.
        """
        # store the root directory
        self._root_directory = root_directory

        # instantiate the analyser
        self._analyser = Analyser(specification_file, root_directory)

        # get the list of all modules that contain functions referred to in the specification
        self._all_modules = self._analyser.get_all_modules()

        # reset instrumented files
        self._reset_instrumented_files()

        # get the ASTs and lines of each of these modules
        self._module_to_ast_list = {}
        self._module_to_lines = {}
        # iterate through modules and construct ASTs for each
        for module in self._all_modules:
            # get asts
            self._module_to_ast_list[module] = self._get_asts_from_module(module)
            # get code lines
            self._module_to_lines[module] = self._get_lines_from_module(module)

        # get the list of all functions used in the specification
        self._all_functions = self._analyser.get_all_functions()

        # get the scfg of each of these functions
        # initialise empty map
        self._function_name_to_scfg_map = {}
        # get SCFG and AST for each function
        for function in self._all_functions:
            # get module from function
            module = self._get_module_from_function(function)
            # get scfg for this function based on self._filename_to_ast_list[filename]
            self._function_name_to_scfg_map[function] = \
                construct_scfg_of_function(module, self._module_to_ast_list[module], function)
        
        # initialise the analyser class
        self._analyser.initialise(self._function_name_to_scfg_map)

        # compute the instrumentation tree
        self._instrumentation_tree = self._analyser.compute_instrumentation_points()
    
    def _reset_instrumented_files(self):
        """
        For each module in self._all_modules, if the backup generated by VyPR exists,
        rename it to the original filename.
        """
        # iterate through modules
        for module in self._all_modules:
            # get backup and original filenames
            backup_filename = self._get_backup_filename_from_module(module)
            original_filename = self._get_original_filename_from_module(module)
            # check for existence
            if os.path.isfile(backup_filename):
                # rename
                os.rename(backup_filename, original_filename)
    
    def _get_module_from_function(self, function: str) -> str:
        """
        Given a function name, extract the module.
        """
        # split the function name
        sequence = function.split(".")
        # remove the function part
        module_part = sequence[:-1]
        # join to get the module name
        module_name = ".".join(module_part)
        return module_name
    
    def _get_asts_from_module(self, module: str) -> list:
        """
        Given a module, get its filename, read in the code from it and construct the ASTs.
        """
        # get filename
        filename = os.path.join(self._root_directory, f"{module}.py")
        # construct file handle
        with open(filename, "r") as h:
            code = h.read()
            asts = ast.parse(code)
            
        return asts
    
    def _get_lines_from_module(self, module: str) -> list:
        """
        Given a module, gets its filename and read in the code lines from it.
        """
        # get filename
        filename = os.path.join(self._root_directory, f"{module}.py")
        # construct file handle
        with open(filename, "r") as h:
            # get trippes lines
            lines = list(map(lambda line : line.rstrip(), h.readlines()))
        
        return lines
    
    def insert_instruments(self):
        """
        Traverse the instrumentation tree structure and, for each symbolic state,
        place an instrument at an appropriate position around the AST provided by the symbolic state.
        """
        # traverse self._instrumentation_tree
        for map_index in self._instrumentation_tree:
            for atom_index in self._instrumentation_tree[map_index]:
                for subatom_index in self._instrumentation_tree[map_index][atom_index]:
                    # iterate through the symbolic states
                    for symbolic_state in self._instrumentation_tree[map_index][atom_index][subatom_index]:
                        # get the index in the block of asts where the instrument's code will be inserted
                        index_in_block = symbolic_state.get_ast_object().parent_block.index(symbolic_state.get_ast_object())
                        # get a neighbouring statement's line number
                        neighbour_line_number = symbolic_state.get_ast_object().parent_block[index_in_block].lineno
                        index = neighbour_line_number - 1
                        # get the function inside which symbolic_state is found
                        function = self._analyser.get_scfg_searcher().get_function_name_of_symbolic_state(symbolic_state)
                        # derive the module name from the function
                        module = self._get_module_from_function(function)
                        # get the indentation level
                        indentation_level = self.get_indentation_level_of_stmt(
                            self._module_to_lines[module][index]
                        )
                        # generate the code to insert
                        instrument_code = self.generate_instrument_code(
                            map_index,
                            atom_index,
                            subatom_index,
                            indentation_level
                        )
                        # insert the code into the code lines
                        self._module_to_lines[module].insert(index, instrument_code)
    
    def get_indentation_level_of_stmt(self, stmt: str) -> int:
        """
        Given a statement, assuming indentation is performed using spaces, count the number of spaces.
        """
        # initialise number of spaces
        number_of_spaces = 0
        # iterate through the string until a non-space character is found
        for i in range(len(stmt)):
            if stmt[i] != " ":
                break
            else:
                number_of_spaces += 1
        
        return number_of_spaces
    
    def generate_instrument_code(self, map_index: int, atom_index: int, subatom_index: int, indentation_level: int) -> str:
        """
        Given the map, atom and subatom indices, generate the code to insert.
        """
        # define code template
        # TODO: make function the instrument calls a parameter
        indentation = " "*indentation_level
        code = f"""{indentation}print(f"map index = {map_index}, atom index = {atom_index}, subatom index = {subatom_index}")"""
        return code
    
    def _get_original_filename_from_module(self, module: str) -> str:
        """
        Given a module name, derive its filename.
        """
        # begin to convert to filename
        with_slashes = module.replace(".", "/").replace(".py", "")
        # join with root directory
        filename = os.path.join(self._root_directory, f"{with_slashes}.py")
        return filename
    
    def _get_backup_filename_from_module(self, module: str) -> str:
        """
        Given a module name, derive its filename.
        """
        # begin to convert to filename
        with_slashes = module.replace(".", "/").replace(".py", "")
        # join with root directory
        filename = os.path.join(self._root_directory, f"{with_slashes}_vypr_original.py")
        return filename
    
    def compile(self):
        """
        Given the modified source code of the modules, write new files (backup old files).
        """
        # iterate through modules
        for module in self._all_modules:

            # get lines for this module
            lines = self._module_to_lines[module]
            # add new lines
            lines = list(map(lambda line : f"{line}\n", lines))

            # get the original and backup filenames from the module
            original_filename = self._get_original_filename_from_module(module)
            backup_filename = self._get_backup_filename_from_module(module)

            # if it exists, rename the backup to the original
            if os.path.isfile(backup_filename):
                os.rename(backup_filename, original_filename)
            
            # copy the original to a backup
            copyfile(original_filename, backup_filename)

            # write the lines for the module to the source file
            with open(original_filename, "w") as h:
                h.writelines(lines)